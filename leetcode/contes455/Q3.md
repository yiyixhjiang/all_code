# 使叶子路径成本相等的最小增量
## 叶子节点到根节点路径花费一致，需要改动多个节点花费；至底到上 没个节点到叶子节点花费一致即可
<img width="853" alt="image" src="https://github.com/user-attachments/assets/c28b1bb4-5a3c-4f28-a301-14e039ee6baf" />
<img width="537" alt="image" src="https://github.com/user-attachments/assets/b50c5bf5-110a-4bbf-bba1-e753c6b5ac2e" />
<img width="625" alt="image" src="https://github.com/user-attachments/assets/4b7d9145-720f-4148-aeba-bae42d5d8e14" />

```python
class Solution(object):
    def minIncrease(self, n, edges, cost):
        """
        :type n: int
        :type edges: List[List[int]]
        :type cost: List[int]
        :rtype: int
        """
        # 计算当前拉链临时值
        def max_cost(nums):
            x_cost = 0
            for num in nums:
                x_cost = max(x_cost, cost[num])
            n = 0
            for num in nums:
                if cost[num] != x_cost: 
                    n += 1
            return n, x_cost
        
        Path = [[] for _ in range(n)]
        ans = 0

        # 构建拉链
        for edge in edges:
            a,b = edge
            Path[a].append(b)
            
        for i in range(n-1, -1, -1):
            if len(Path[i]) > 0:
                n, x_cost  = max_cost(Path[i])
                ans += n
                cost[i] += x_cost

        return ans
        
        
```
