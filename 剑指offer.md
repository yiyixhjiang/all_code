<!-- GFM-TOC -->
* [1. 前言](#1-前言)
* [2. 实现 Singleton](#2-实现-singleton)
* [3. 数组中重复的数字](#3-数组中重复的数字)
* [4. 二维数组中的查找](#4-二维数组中的查找)
* [5. 替换空格](#5-替换空格)
* [6. 从尾到头打印链表](#6-从尾到头打印链表)
* [7. 重建二叉树](#7-重建二叉树)
* [8. 二叉树的下一个结点](#8-二叉树的下一个结点)
* [9. 用两个栈实现队列](#9-用两个栈实现队列)
* [10.1 斐波那契数列](#101-斐波那契数列)
* [10.2 跳台阶](#102-跳台阶)
* [10.3 矩形覆盖](#103-矩形覆盖)
* [10.4 变态跳台阶](#104-变态跳台阶)
* [11. 旋转数组的最小数字](#11-旋转数组的最小数字)
* [12. 矩阵中的路径](#12-矩阵中的路径)
* [13. 机器人的运动范围](#13-机器人的运动范围)
* [14. 剪绳子](#14-剪绳子)
* [15. 二进制中 1 的个数](#15-二进制中-1-的个数)
* [16. 数值的整数次方](#16-数值的整数次方)
* [17. 打印从 1 到最大的 n 位数](#17-打印从-1-到最大的-n-位数)
* [18.1 在 O(1) 时间内删除链表节点](#181-在-o1-时间内删除链表节点)
* [18.2 删除链表中重复的结点](#182-删除链表中重复的结点)
* [19. 正则表达式匹配](#19-正则表达式匹配)
* [20. 表示数值的字符串](#20-表示数值的字符串)
* [21. 调整数组顺序使奇数位于偶数前面](#21-调整数组顺序使奇数位于偶数前面)
* [22. 链表中倒数第 K 个结点](#22-链表中倒数第-k-个结点)
* [23. 链表中环的入口结点](#23-链表中环的入口结点)
* [24. 反转链表](#24-反转链表)
* [25. 合并两个排序的链表](#25-合并两个排序的链表)
* [26. 树的子结构](#26-树的子结构)
* [27. 二叉树的镜像](#27-二叉树的镜像)
* [28 对称的二叉树](#28-对称的二叉树)
* [29. 顺时针打印矩阵](#29-顺时针打印矩阵)
* [30. 包含 min 函数的栈](#30-包含-min-函数的栈)
* [31. 栈的压入、弹出序列](#31-栈的压入弹出序列)
* [32.1 从上往下打印二叉树](#321-从上往下打印二叉树)
* [32.2 把二叉树打印成多行](#322-把二叉树打印成多行)
* [32.3 按之字形顺序打印二叉树](#323-按之字形顺序打印二叉树)
* [33. 二叉搜索树的后序遍历序列](#33-二叉搜索树的后序遍历序列)
* [34. 二叉树中和为某一值的路径](#34-二叉树中和为某一值的路径)
* [35. 复杂链表的复制](#35-复杂链表的复制)
* [36. 二叉搜索树与双向链表](#36-二叉搜索树与双向链表)
* [37. 序列化二叉树](#37-序列化二叉树)
* [38. 字符串的排列](#38-字符串的排列)
* [39. 数组中出现次数超过一半的数字](#39-数组中出现次数超过一半的数字)
* [40. 最小的 K 个数](#40-最小的-k-个数)
* [41.1 数据流中的中位数](#411-数据流中的中位数)
* [41.2 字符流中第一个不重复的字符](#412-字符流中第一个不重复的字符)
* [42. 连续子数组的最大和](#42-连续子数组的最大和)
* [43. 从 1 到 n 整数中 1 出现的次数](#43-从-1-到-n-整数中-1-出现的次数)
* [44. 数字序列中的某一位数字](#44-数字序列中的某一位数字)
* [45. 把数组排成最小的数](#45-把数组排成最小的数)
* [46. 把数字翻译成字符串](#46-把数字翻译成字符串)
* [47. 礼物的最大价值](#47-礼物的最大价值)
* [48. 最长不含重复字符的子字符串](#48-最长不含重复字符的子字符串)
* [49. 丑数](#49-丑数)
* [50. 第一个只出现一次的字符位置](#50-第一个只出现一次的字符位置)
* [51. 数组中的逆序对](#51-数组中的逆序对)
* [52. 两个链表的第一个公共结点](#52-两个链表的第一个公共结点)
* [53. 数字在排序数组中出现的次数](#53-数字在排序数组中出现的次数)
* [54. 二叉查找树的第 K 个结点](#54-二叉查找树的第-k-个结点)
* [55.1 二叉树的深度](#551-二叉树的深度)
* [55.2 平衡二叉树](#552-平衡二叉树)
* [56. 数组中只出现一次的数字](#56-数组中只出现一次的数字)
* [57.1 和为 S 的两个数字](#571-和为-s-的两个数字)
* [57.2 和为 S 的连续正数序列](#572-和为-s-的连续正数序列)
* [58.1 翻转单词顺序列](#581-翻转单词顺序列)
* [58.2 左旋转字符串](#582-左旋转字符串)
* [59. 滑动窗口的最大值](#59-滑动窗口的最大值)
* [60. n 个骰子的点数](#60-n-个骰子的点数)
* [61. 扑克牌顺子](#61-扑克牌顺子)
* [62. 圆圈中最后剩下的数](#62-圆圈中最后剩下的数)
* [63. 股票的最大利润](#63-股票的最大利润)
* [64. 求 1+2+3+...+n](#64-求-123n)
* [65. 不用加减乘除做加法](#65-不用加减乘除做加法)
* [66. 构建乘积数组](#66-构建乘积数组)
* [67. 把字符串转换成整数](#67-把字符串转换成整数)
* [68. 树中两个节点的最低公共祖先](#68-树中两个节点的最低公共祖先)
* [参考文献](#参考文献)
<!-- GFM-TOC -->


# 1. 前言

本文的绘图可通过以下途径免费获得并使用：

- [ProcessOn](https://www.processon.com/view/5a3e4c7be4b0909c1aa18b49)
- [DrawIO](https://drive.google.com/file/d/1nSSCpPUC05MFoeFuf_aeTtkm7dG5-bJ1/view?usp=sharing)

# 2. 实现 Singleton

[单例模式](https://github.com/CyC2018/Interview-Notebook/blob/master/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.md)

# 3. 数组中重复的数字

[NowCoder](https://www.nowcoder.com/practice/623a5ac0ea5b4e5f95552655361ae0a8?tpId=13&tqId=11203&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 题目描述

在一个长度为 n 的数组里的所有数字都在 0 到 n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字是重复的，也不知道每个数字重复几次。请找出数组中任意一个重复的数字。

```html
Input:
{2, 3, 1, 0, 2, 5}

Output:
2
```

## 解题思路

要求复杂度为 O(N) + O(1)，也就是时间复杂度 O(N)，空间复杂度 O(1)。因此不能使用排序的方法，也不能使用额外的标记数组。牛客网讨论区这一题的首票答案使用 nums[i] + length 来将元素标记，这么做会有加法溢出问题。

这种数组元素在 [0, n-1] 范围内的问题，可以将值为 i 的元素调整到第 i 个位置上。

以 (2, 3, 1, 0, 2, 5) 为例：

```text
position-0 : (2,3,1,0,2,5) // 2 <-> 1
             (1,3,2,0,2,5) // 1 <-> 3
             (3,1,2,0,2,5) // 3 <-> 0
             (0,1,2,3,2,5) // already in position
position-1 : (0,1,2,3,2,5) // already in position
position-2 : (0,1,2,3,2,5) // already in position
position-3 : (0,1,2,3,2,5) // already in position
position-4 : (0,1,2,3,2,5) // nums[i] == nums[nums[i]], exit
```

遍历到位置 4 时，该位置上的数为 2，但是第 2 个位置上已经有一个 2 的值了，因此可以知道 2 重复。

```c++
class Solution {
public:
    // Parameters:
    // numbers:     an array of integers
    // length:      the length of array numbers
    // duplication: (Output) the duplicated number in the array number
    // Return value: true if the input is valid, and there are some duplications in the array number
    // otherwise false
    bool duplicate(int numbers[], int length, int* duplication) {
        if(numbers == NULL || length <= 0) return false;
        for(int i = 0; i < length; i ++)
        {
            while(numbers[i] != i) // 每一轮把i节点放到合适的位置
            {
                if(numbers[i] == numbers[numbers[i]])
                {
                    duplication[0] = numbers[i];
                    return true;
                }
                else
                    swap(numbers[i], numbers[numbers[i]]);
            }
        }
        return false;
    }
};
```

# 4. 二维数组中的查找

[NowCoder](https://www.nowcoder.com/practice/abc3fe2ce8e146608e868a70efebf62e?tpId=13&tqId=11154&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 题目描述

在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。

```html
Consider the following matrix:
[
  [1,   4,  7, 11, 15],
  [2,   5,  8, 12, 19],
  [3,   6,  9, 16, 22],
  [10, 13, 14, 17, 24],
  [18, 21, 23, 26, 30]
]

Given target = 5, return true.
Given target = 20, return false.
```

## 解题思路

从右上角开始查找。矩阵中的一个数，它左边的数都比它小，下边的数都比它大。因此，从右上角开始查找，就可以根据 target 和当前元素的大小关系来缩小查找区间。

复杂度：O(M + N) + O(1)

当前元素的查找区间为左下角的所有元素，例如元素 12 的查找区间如下：

<div align="center"> <img src="../pics//f94389e9-55b1-4f49-9d37-00ed05900ae0.png" width="250"/> </div><br>

```c++
class Solution {
public:
    bool Find(int target, vector<vector<int> > array) {
        if(array.empty()) return false;
        int n = array.size()-1, m = array.front().size()-1;
        int x = 0, y = m;
        while(x <= n && y >= 0)
        {
            if(target == array[x][y])
                return true;
            if(target < array[x][y])
                y --;
            else 
                x ++;
        }
        return false;
    }
};
```

# 5. 替换空格

[NowCoder](https://www.nowcoder.com/practice/4060ac7e3e404ad1a894ef3e17650423?tpId=13&tqId=11155&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 题目描述


将一个字符串中的空格替换成 "%20"。

```text
Input:
"We Are Happy"

Output:
"We%20Are%20Happy"
```

## 解题思路

在字符串尾部填充任意字符，使得字符串的长度等于替换之后的长度。因为一个空格要替换成三个字符（%20），因此当遍历到一个空格时，需要在尾部填充两个任意字符。

令 P1 指向字符串原来的末尾位置，P2 指向字符串现在的末尾位置。P1 和 P2从后向前遍历，当 P1 遍历到一个空格时，就需要令 P2 指向的位置依次填充 02%（注意是逆序的），否则就填充上 P1 指向字符的值。

从后向前遍是为了在改变 P2 所指向的内容时，不会影响到 P1 遍历原来字符串的内容。

```c++
class Solution {
public:
	void replaceSpace(char *str, int length) {
        int length_temp = length;
        for(int i = 0; i < length; i ++)
            if(str[i] == ' ')
                length_temp += 2;
        
        for(int i = length-1; i >= 0; i --)
        {
            if(str[i] == ' ')
            {
                str[-- length_temp] = '0';
                str[-- length_temp] = '2';
                str[-- length_temp] = '%';
            }
            else
                str[-- length_temp] = str[i];
        }
	}
};
```

# 6. 从尾到头打印链表

[NowCoder](https://www.nowcoder.com/practice/d0267f7f55b3412ba93bd35cfa8e8035?tpId=13&tqId=11156&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 题目描述

输入链表的第一个节点，从尾到头反过来打印出每个结点的值。

<div align="center"> <img src="../pics//d99dc9e2-197c-4085-813d-7195da1c6762.png" width="300"/> </div><br>

## 解题思路

### 使用vector，再做reserve;

```c++
class Solution {
public:
    vector<int> printListFromTailToHead(ListNode* head) {
        vector<int> res;
        while(head != NULL)
        {
            res.push_back(head -> val);
            head = head -> next;
        }
        reverse(res.begin(), res.end());
        return res;
    }
};
```

# 7. 重建二叉树

[NowCoder](https://www.nowcoder.com/practice/8a19cbe657394eeaac2f6ea9b0f6fcf6?tpId=13&tqId=11157&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 题目描述

根据二叉树的前序遍历和中序遍历的结果，重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。

```html
preorder = [3,9,20,15,7]
inorder =  [9,3,15,20,7]
```

<div align="center"> <img src="../pics//8a4c6ad4-a816-47d1-b93f-7ca4f78ab67a.png" width="250"/> </div><br>

## 解题思路

前序遍历的第一个值为根节点的值，使用这个值将中序遍历结果分成两部分，左部分为树的左子树中序遍历结果，右部分为树的右子树中序遍历的结果。

```c++
class Solution {
public:
    TreeNode* reConstructBinaryTree(vector<int> pre,vector<int> vin) {
        if(pre.empty()) return NULL;
        TreeNode * ans = new TreeNode(pre[0]);
        vector<int> pre_1, pre_2;
        vector<int> vin_1, vin_2;
        
        for(int i = 0; i < vin.size(); i ++)
        {
            if(vin[i] == pre[0])
            {
                pre_1.assign(pre.begin() + 1, pre.begin() + 1 + i);
                pre_2.assign(pre.begin() + 1 + i, pre.end());
                
                vin_1.assign(vin.begin(), vin.begin() + i);
                vin_2.assign(vin.begin() + i + 1, vin.end());
            }
        }
        ans->left = reConstructBinaryTree(pre_1, vin_1);
        ans->right = reConstructBinaryTree(pre_2, vin_2);
        return ans;
    }
};
```

# 8. 二叉树的下一个结点

[NowCoder](https://www.nowcoder.com/practice/9023a0c988684a53960365b889ceaf5e?tpId=13&tqId=11210&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 题目描述

给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。

```c++
struct TreeLinkNode {
    int val;
    struct TreeLinkNode *left;
    struct TreeLinkNode *right;
    struct TreeLinkNode *next;
    TreeLinkNode(int x) :val(x), left(NULL), right(NULL), next(NULL) {
        
    }
};
```

## 解题思路

① 如果一个节点的右子树不为空，那么该节点的下一个节点是右子树的最左节点；
<div align="center"> <img src="../pics//cb0ed469-27ab-471b-a830-648b279103c8.png" width="250"/> </div><br>
② 否则，向上找第一个左链接指向的树包含该节点的祖先节点。
<div align="center"> <img src="../pics//e143f6da-d114-4ba4-8712-f65299047fa2.png" width="250"/> </div><br>

```c++
class Solution {
public:
    TreeLinkNode* GetNext(TreeLinkNode* pNode)
    {
        if(pNode->right != NULL)
        {
            TreeLinkNode * t_Node = pNode->right;
            while(t_Node->left != NULL)
            {
                t_Node = t_Node->left;
            }
            return t_Node;
        }
        while(pNode->next != NULL)
        {
            TreeLinkNode * t_Node = pNode->next;
            if(t_Node->left == pNode)
                return t_Node;
            pNode = pNode->next;
        }
        return NULL;
     }
};
```

# 9. 用两个栈实现队列

[NowCoder](https://www.nowcoder.com/practice/54275ddae22f475981afa2244dd448c6?tpId=13&tqId=11158&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 题目描述

用两个栈来实现一个队列，完成队列的 Push 和 Pop 操作。

## 解题思路

in 栈用来处理入栈（push）操作，out 栈用来处理出栈（pop）操作。一个元素进入 in 栈之后，出栈的顺序被反转。当元素要出栈时，需要先进入 out 栈，此时元素出栈顺序再一次被反转，因此出栈顺序就和最开始入栈顺序是相同的，先进入的元素先退出，这就是队列的顺序。

<div align="center"> <img src="../pics//5acf7550-86c5-4c5b-b912-8ce70ef9c34e.png" width="400"/> </div><br>
- 注意stack是push(),pop()

```c++
class Solution
{
private:
    stack<int> stack1;
    stack<int> stack2;
public:
    void push(int node) {
        stack1.push(node);
    }
    int pop() {
        while(!stack1.empty())
        {
            stack2.push(stack1.top());
            stack1.pop();
        }
        int x = stack2.top();
        stack2.pop();
        while(!stack2.empty())
        {
            stack1.push(stack2.top());
            stack2.pop();
        }
        return x;
    }
};
```

# 10.1 斐波那契数列

[NowCoder](https://www.nowcoder.com/practice/c6c7742f5ba7442aada113136ddea0c3?tpId=13&tqId=11160&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 题目描述

求斐波那契数列的第 n 项，n <= 39。

## 解题思路

如果使用递归求解，会重复计算一些子问题。例如，计算 f(10) 需要计算 f(9) 和 f(8)，计算 f(9) 需要计算 f(8) 和 f(7)，可以看到 f(8) 被重复计算了。

<div align="center"> <img src="../pics//faecea49-9974-40db-9821-c8636137df61.jpg" width="300"/> </div><br>

递归是将一个问题划分成多个子问题求解，动态规划也是如此，但是动态规划会把子问题的解缓存起来，从而避免重复求解子问题。

```c++
class Solution {
public:
    int Fi[1009]={0};
    int Fibonacci(int n) {
        if(n == 0) 
            return 0;
        if(n == 1) 
            return 1;
        return Fi[n] == 0 ? Fi[n] = Fibonacci(n-1) + Fibonacci(n-2) : Fi[n]; 
    }
};
```

考虑到第 i 项只与第 i-1 和第 i-2 项有关，因此只需要存储前两项的值就能求解第 i 项，从而将空间复杂度由 O(N) 降低为 O(1)。


# 10.2 跳台阶

[NowCoder](https://www.nowcoder.com/practice/8c82a5b80378478f9484d87d1c5f12a4?tpId=13&tqId=11161&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 题目描述

一只青蛙一次可以跳上 1 级台阶，也可以跳上 2 级。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。

## 解题思路

```c++
class Solution {
public:
    int ju[1009] = {0};
    int jumpFloor(int n) {
        if(n == 1) return 1;
        if(n == 2) return 2;
        return ju[n] == 0 ? ju[n] = jumpFloor(n-1) + jumpFloor(n-2) : ju[n];
    }
};
```

# 10.3 矩形覆盖

[NowCoder](https://www.nowcoder.com/practice/72a5a919508a4251859fb2cfb987a0e6?tpId=13&tqId=11163&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 题目描述

我们可以用 2\*1 的小矩形横着或者竖着去覆盖更大的矩形。请问用 n 个 2\*1 的小矩形无重叠地覆盖一个 2\*n 的大矩形，总共有多少种方法？

## 解题思路 数据范围扩大了，不使用数组缓存。

```c++
class Solution {
public:
    int rectCover(int n) {
        int pre1 = 1;
        int pre2 = 2;
        int ans;
        if(n <= 2) return n;
        for(int i = 3; i <= n; i ++)
        {
            ans = pre1 + pre2;
            pre1 = pre2;
            pre2 = ans;
        }
        return ans;
    }
};
```

# 10.4 变态跳台阶

[NowCoder](https://www.nowcoder.com/practice/22243d016f6b47f2a6928b4313c85387?tpId=13&tqId=11162&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 题目描述

一只青蛙一次可以跳上 1 级台阶，也可以跳上 2 级... 它也可以跳上 n 级。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。
- 0101010  1 1代表落下过最终到1 2^(n-1);
## 解题思路

```c++
class Solution {
public:
    int jumpFloorII(int number) {
		if(number == 1) return 1;
        if(number == 2) return 2;
        int f1 = 1, f2 = 2, f3;
        for(int i = 3; i <= number; i ++)
        {
            f3 = 2 * f2;
            f2 = f3;
        }
        return f3;
    }
};
```

# 11. 旋转数组的最小数字

[NowCoder](https://www.nowcoder.com/practice/9f3231a991af4f55b95579b44b7a01ba?tpId=13&tqId=11159&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 题目描述

把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。

例如数组 {3, 4, 5, 1, 2} 为 {1, 2, 3, 4, 5} 的一个旋转，该数组的最小值为 1。

## 解题思路

在一个有序数组中查找一个元素可以用二分查找，二分查找也称为折半查找，每次都能将查找区间减半，这种折半特性的算法时间复杂度都为 O(logN)。

本题可以修改二分查找算法进行求解：

- 当 nums[m] <= nums[h] 的情况下，说明解在 [l, m] 之间，此时令 h = m；
- 否则解在 [m + 1, h] 之间，令 l = m + 1。

```c++
class Solution {
public:
    int minNumberInRotateArray(vector<int> ve) {
        int left = 0, right = ve.size()-1;
        while(left < right)
        {
            int mid = (left + right) >> 1;
            if(ve[mid] < ve[right])
                right = mid;
            else if(ve[mid] > ve[right])
                left = mid + 1;
            else right = right - 1;
        }
        return ve[left];
    }
};
```

如果数组元素允许重复的话，那么就会出现一个特殊的情况：nums[l] == nums[m] == nums[h]，那么此时无法确定解在哪个区间，需要切换到顺序查找。例如对于数组 {1,1,1,0,1}，l、m 和 h 指向的数都为 1，此时无法知道最小数字 0 在哪个区间。


# 12. 矩阵中的路径

[NowCoder](https://www.nowcoder.com/practice/c61c6999eecb4b8f88a98f66b273a3cc?tpId=13&tqId=11218&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 题目描述

请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。

例如下面的矩阵包含了一条 bfce 路径。

<div align="center"> <img src="../pics//e31abb94-9201-4e06-9902-61101b92f475.png" width="300"/> </div><br>

## 解题思路

```c++
class Solution {
public:
    bool inPath(char * matrix, int rows, int cols, int x, int y, 
                char * str, vector<vector<int>> visit)
    {
        if( (*str) == '\0') return true;
        int d[4][2] = {-1,0,  1,0, 0,-1, 0,1};
        if(x < rows && x >= 0 && y < cols && y >= 0 &&
           str[0] == matrix[cols*x + y] && visit[x][y] == 0)
        {
            visit[x][y] = 1;
            bool flag = false;
            str ++;
            for(int i = 0; i < 4; i ++)
            {
                int x_ = x + d[i][0];
                int y_ = y + d[i][1];
                flag = flag || inPath(matrix,rows,cols,x_, y_, str, visit);
            }
            return flag;
        }
        return false;
    }
    
    bool hasPath(char* matrix, int rows, int cols, char* str)
    {
        vector<vector<int>> visit(rows, vector<int>(cols, 0));
        for(int i = 0; i < rows; i ++)
            for(int j = 0; j < cols; j ++)
            {
                if(inPath(matrix, rows, cols, i, j, str, visit))
                    return true;
            }
        return false;
    }
};
```

# 13. 机器人的运动范围

[NowCoder](https://www.nowcoder.com/practice/6e5207314b5241fb83f2329e89fdecc8?tpId=13&tqId=11219&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 题目描述

地上有一个 m 行和 n 列的方格。一个机器人从坐标 (0, 0) 的格子开始移动，每一次只能向左右上下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于 k 的格子。

例如，当 k 为 18 时，机器人能够进入方格 (35,37)，因为 3+5+3+7=18。但是，它不能进入方格 (35,37)，因为 3+5+3+8=19。请问该机器人能够达到多少个格子？

## 解题思路

```c++
class Solution {
public:
    int sum_num(int x)
    {
        int ans = 0;
        while(x)
        {
            ans += x % 10;
            x /= 10; 
        }
        return ans;
    }
    bool ok(int t, int x, int y)
    {
        return sum_num(x) + sum_num(y) <= t;
    }
    int d[4][2] = {0,1, 0,-1, 1,0, -1,0};
    void bfs(int threshold, int rows, int cols, int x, int y, int & ans, vector<vector<int>> &visit)
    {
        if(x < rows && x >= 0 && y < cols && y >= 0 && ok(threshold, x, y) && visit[x][y] == 0)
        {
            ans ++;
            visit[x][y] = 1;
            for(int i = 0; i < 4; i ++)
            {
                int _x = x + d[i][0];
                int _y = y + d[i][1];
                Count(threshold, rows, cols, _x, _y, ans, visit);
            }
        }
        return;
    }
    int movingCount(int threshold, int rows, int cols)
    {
        int ans = 0;
        vector<vector<int>> visit(rows, vector<int>(cols, 0));
        bfs(threshold, rows, cols, 0, 0, ans, visit);
        return ans;
    }
};
```

# 14. 剪绳子

[Leetcode](https://leetcode.com/problems/integer-break/description/)

## 题目描述

把一根绳子剪成多段，并且使得每段的长度乘积最大。

```html
n = 2
return 1 (2 = 1 + 1)

n = 10
return 36 (10 = 3 + 3 + 4)
```

## 解题思路

### 贪心

尽可能多剪长度为 3 的绳子，并且不允许有长度为 1 的绳子出现。如果出现了，就从已经切好长度为 3 的绳子中拿出一段与长度为 1 的绳子重新组合，把它们切成两段长度为 2 的绳子。

证明：当 n >= 5 时，3(n - 3) - 2(n - 2) = n - 5 >= 0。因此把长度大于 5 的绳子切成两段，令其中一段长度为 3 可以使得两段的乘积最大。

```c++
class Solution {
public:
    int integerBreak(int n) {
        if(n < 2) return 0;
        if(n == 2) return 1;
        if(n == 3) return 2; //先考虑特殊情况
        int time = n/3;
        int remain = n%3;
        if(remain == 1)
            return (int)pow(3, time-1) * 4;
        else 
            return (int)pow(3, time) * (remain == 0 ? 1 : remain);
    }
};
```

### 动态规划

```c++
class Solution {
public:
    int integerBreak(int n) {
        vector<int> dp(n+1,0);
        dp[1] = 1;
        for(int i = 2; i <= n; i ++)
        {
            for(int j = 1; j < i; j ++)
                dp[i] = max(dp[i], max(dp[j], j) *(i-j)); 
                // dp[j]表示j至少要分开成两部分后的最优值，所以需要我们还要考虑j单独的情况 最优值判断。
        }
        return dp[n];
    }
};
```

# 15. 二进制中 1 的个数

[NowCoder](https://www.nowcoder.com/practice/8ee967e43c2c4ec193b040ea7fbb10b8?tpId=13&tqId=11164&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 题目描述

输入一个整数，输出该数二进制表示中 1 的个数。

### n&(n-1)

该位运算去除 n 的位级表示中最低的那一位。

```
n       : 10110100
n-1     : 10110011
n&(n-1) : 10110000
```

时间复杂度：O(M)，其中 M 表示 1 的个数。


```c++
class Solution {
public:
     int  NumberOf1(int n) {
         if(n == 0) return 0;
         int ans = 1;
         n = (n & (n-1));
         while(n)
         {
             ans ++;
             n = n & (n-1);
         }
         return ans;
     }
};
```

# 16. 数值的整数次方

[NowCoder](https://www.nowcoder.com/practice/1a834e5e3e1a4b7ba251417554e07c00?tpId=13&tqId=11165&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 题目描述

给定一个 double 类型的浮点数 base 和 int 类型的整数 exponent，求 base 的 exponent 次方。

## 解题思路

下面的讨论中 x 代表 base，n 代表 exponent。

<div align="center"><img src="https://latex.codecogs.com/gif.latex?x^n=\left\{\begin{array}{rcl}(x*x)^{n/2}&&{n\%2=0}\\x*(x*x)^{n/2}&&{n\%2=1}\end{array}\right."/></div> <br>

因为 (x\*x)<sup>n/2</sup> 可以通过递归求解，并且每次递归 n 都减小一半，因此整个算法的时间复杂度为 O(logN)。

```c++
class Solution {
public:
    double Power(double base, int exponent) {
        double ans = 1;
        double temp = base;
        bool flag = true;
        if(exponent < 0)
            flag = false;
        exponent = abs(exponent);
        while(exponent)
        {
            
            if(exponent & 1)
            {
                ans *= temp;
            }
            temp *= base;
            exponent = exponent >> 1; 
        }
        return flag ? ans : 1.0 / ans;
    }
};
```

# 17. 打印从 1 到最大的 n 位数

## 题目描述

输入数字 n，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数即 999。

## 解题思路

由于 n 可能会非常大，因此不能直接用 int 表示数字，而是用 char 数组进行存储。

使用回溯法得到所有的数。

```c++
void print1ToMaxN(int n)
{
    if(n < 0) return;
    char * number = new char[n];
    print1ToMax(number, n, 0);
    delete [] number;
}
void print1ToMax(char * number, int length, int index)
{
    if(index == length)
    {
        print_(number, length);
        return;
    }
    for(int i = 0; i < 10; i ++)
    {
        number[index] = i + '0';
        print1ToMax(number, length, index + 1);
    }
    return;
}
void print_(char * number, int length)
{
    int i = 0;
    while(number[i] == '0' && i < length)
        i ++;
    for(int j = i; j < length; j ++) 
        cout << number[j];
    if(i < length) cout << endl;
    return;
}
```

# 18.1 在 O(1) 时间内删除链表节点

## 解题思路

① 如果该节点不是尾节点，那么可以直接将下一个节点的值赋给该节点，然后令该节点指向下下个节点，再删除下一个节点，时间复杂度为 O(1)。

<div align="center"> <img src="../pics//27ff9548-edb6-4465-92c8-7e6386e0b185.png" width="600"/> </div><br>

② 否则，就需要先遍历链表，找到节点的前一个节点，然后让前一个节点指向 null，时间复杂度为 O(N)。

<div align="center"> <img src="../pics//280f7728-594f-4811-a03a-fa8d32c013da.png" width="600"/> </div><br>

综上，如果进行 N 次操作，那么大约需要操作节点的次数为 N-1+N=2N-1，其中 N-1 表示 N-1 个不是尾节点的每个节点以 O(1) 的时间复杂度操作节点的总次数，N 表示 1 个尾节点以 O(N) 的时间复杂度操作节点的总次数。(2N-1)/N \~ 2，因此该算法的平均时间复杂度为 O(1)。

```java
public ListNode deleteNode(ListNode head, ListNode tobeDelete) {
    if (head == null || head.next == null || tobeDelete == null)
        return null;
    if (tobeDelete.next != null) {
        // 要删除的节点不是尾节点
        ListNode next = tobeDelete.next;
        tobeDelete.val = next.val;
        tobeDelete.next = next.next;
    } else {
        ListNode cur = head;
        while (cur.next != tobeDelete)
            cur = cur.next;
        cur.next = null;
    }
    return head;
}
```

# 18.2 删除链表中重复的结点

[NowCoder](https://www.nowcoder.com/practice/fc533c45b73a41b0b44ccba763f866ef?tpId=13&tqId=11209&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 题目描述

<div align="center"> <img src="../pics//8433fbb2-c35c-45ef-831d-e3ca42aebd51.png" width="500"/> </div><br>

## 解题描述

```c++
class Solution {
public:
    ListNode* deleteDuplication(ListNode* pHead)
    {
        if(pHead == NULL || pHead->next == NULL) return pHead;
        ListNode* ans = pHead;
        if(pHead->val == pHead->next->val)
        {
            while((pHead->next != NULL) && (pHead->val == pHead->next->val))
                pHead = pHead->next;
            return deleteDuplication(pHead->next);
        }
        else 
            ans->next = deleteDuplication(pHead->next);
        return ans;
    }
};
```

# 19. 正则表达式匹配

[NowCoder](https://www.nowcoder.com/practice/45327ae22b7b413ea21df13ee7d6429c?tpId=13&tqId=11205&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 题目描述

请实现一个函数用来匹配包括 '.' 和 '\*' 的正则表达式。模式中的字符 '.' 表示任意一个字符，而 '\*' 表示它前面的字符可以出现任意次（包含 0 次）。

在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串 "aaa" 与模式 "a.a" 和 "ab\*ac\*a" 匹配，但是与 "aa.a" 和 "ab\*a" 均不匹配。

## 解题思路

应该注意到，'.' 是用来当做一个任意字符，而 '\*' 是用来重复前面的字符。这两个的作用不同，不能把 '.' 的作用和 '\*' 进行类比，从而把它当成重复前面字符一次。

```c++
class Solution {
public:
    bool match(char* str, char* pattern)
    {
        if((*str == '\0') && (*pattern == '\0')) return true;
        if(*str != '\0' && *pattern == '\0') return false;
        
        if(*(pattern + 1) == '*')
        {
            if( (*str == *pattern) || (*str != '\0' && *pattern == '.')) 
                return match(str+1, pattern) || match(str, pattern+2);
            else 
                return  match(str, pattern+2);
        }
        else
        {
            if(*str == *pattern || (*str != '\0' && *pattern == '.'))
                return match(str+1, pattern+1);
            else
                return false;
        }
        return false;
    }
};
```

# 20. 表示数值的字符串

[NowCoder](https://www.nowcoder.com/practice/6f8c901d091949a5837e24bb82a731f2?tpId=13&tqId=11206&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 题目描述

```html
true

"+100"
"5e2"
"-123"
"3.1416"
"-1E-16"

false

"12e"
"1a3.14"
"1.2.3"
"+-5"
"12e+4.3"
```


## 解题思路

使用正则表达式进行匹配。

```html
[]  ： 字符集合
()  ： 分组
?   ： 重复 0 ~ 1
+   ： 重复 1 ~ n
*   ： 重复 0 ~ n
.   ： 任意字符
\\. ： 转义后的 .
\\d ： 数字
```

```java
public boolean isNumeric(char[] str) {
    if (str == null)
        return false;
    return new String(str).matches("[+-]?\\d*(\\.\\d+)?([eE][+-]?\\d+)?");
}
```

# 21. 调整数组顺序使奇数位于偶数前面

[NowCoder](https://www.nowcoder.com/practice/beb5aa231adc45b2a5dcc5b62c93f593?tpId=13&tqId=11166&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 题目描述

需要保证奇数和奇数，偶数和偶数之间的相对位置不变，这和书本不太一样。

## 解题思路

```c++
class Solution {
public:
    void reOrderArray(vector<int> &array) {
        int len = array.size();
        auto it = array.begin();
        while(len --)
        {
            if( (*it & 1) == 0)
            {
                int temp = *it;
                it = array.erase(it);
                array.push_back(temp);
            }
            else
                it ++;
        }
    }
};
```

# 22. 链表中倒数第 K 个结点

[NowCoder](https://www.nowcoder.com/practice/529d3ae5a407492994ad2a246518148a?tpId=13&tqId=11167&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 解题思路

设链表的长度为 N。设两个指针 P1 和 P2，先让 P1 移动 K 个节点，则还有 N - K 个节点可以移动。此时让 P1 和 P2 同时移动，可以知道当 P1 移动到链表结尾时，P2 移动到 N - K 个节点处，该位置就是倒数第 K 个节点。

<div align="center"> <img src="../pics//ea2304ce-268b-4238-9486-4d8f8aea8ca4.png" width="500"/> </div><br>

```c++
class Solution {
public:
    ListNode* FindKthToTail(ListNode* pListHead, unsigned int k) {
        ListNode * temp = pListHead;
        for(int i = 0; i < k; i ++)
        {
            if(temp == NULL) 
                return NULL;
            temp = temp->next;
        }
        while(temp != NULL)
        {
            pListHead = pListHead->next;
            temp = temp->next;
        }
        return pListHead;
    }
};
```

# 23. 链表中环的入口结点

[NowCoder](https://www.nowcoder.com/practice/253d2c59ec3e4bc68da16833f79a38e4?tpId=13&tqId=11208&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 题目描述

一个链表中包含环，请找出该链表的环的入口结点。要求不能使用额外的空间。

## 解题思路

使用双指针，一个指针 fast 每次移动两个节点，一个指针 slow 每次移动一个节点。因为存在环，所以两个指针必定相遇在环中的某个节点上。假设相遇点在下图的 z1 位置，此时 fast 移动的节点数为 x+2y+z，slow 为 x+y，由于 fast 速度比 slow 快一倍，因此 x+2y+z=2(x+y)，得到 x=z。

在相遇点，slow 要到环的入口点还需要移动 z 个节点，如果让 fast 重新从头开始移动，并且速度变为每次移动一个节点，那么它到环入口点还需要移动 x 个节点。在上面已经推导出 x=z，因此 fast 和 slow 将在环入口点相遇。

<div align="center"> <img src="../pics//2858f8ad-aedb-45a5-a706-e98c96d690fa.jpg" width="600"/> </div><br>

```c++
class Solution { //从向交的地方在向下走，环前长度为n = k*r - x, n步之后 刚好会在入口
public:
    ListNode* EntryNodeOfLoop(ListNode* pHead)
    {
        ListNode * fast, * slow;
        fast = slow = pHead;
        while(fast != NULL && fast->next != NULL)
        {
            slow = slow->next;
            fast = fast->next->next;
            if(slow == fast)
            {
                fast = pHead;
                while(fast != slow)
                {
                    fast = fast->next;
                    slow = slow->next;
                }
                return slow;
            }
        }
        return NULL;
    }
};
```

# 24. 反转链表

[NowCoder](https://www.nowcoder.com/practice/75e878df47f24fdc9dc3e400ec6058ca?tpId=13&tqId=11168&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 解题思路

### 递归

```c++
class Solution {
public:
    ListNode* ReverseList(ListNode* pHead) {
        if(pHead == NULL || pHead->next == NULL)
            return pHead;
        ListNode * Next = pHead->next;
        pHead->next = NULL;
        ListNode * Temp = ReverseList(Next);
        Next->next = pHead;
        return Temp;
    }
};
```

### 迭代
- 构造两个指针一个指前面一个位置 一个指向后面一个位置

```c++ 
class Solution {
public:
    ListNode* ReverseList(ListNode* pHead) {
        ListNode * pre = NULL;
        ListNode * next = NULL;
        while(pHead != NULL)
        {
            next = pHead->next;
            pHead->next = pre;
            pre = pHead;
            pHead = next;
        }
        return pre;
    }
};
```

# 25. 合并两个排序的链表

[NowCoder](https://www.nowcoder.com/practice/d8b6b4358f774294a89de2a6ac4d9337?tpId=13&tqId=11169&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 题目描述

<div align="center"> <img src="../pics//43f2cafa-3568-4a89-a895-4725666b94a6.png" width="500"/> </div><br>

## 解题思路

### 递归

```c++
class Solution {
public:
    ListNode* Merge(ListNode* pHead1, ListNode* pHead2)
    {
        if(pHead1 == NULL) 
            return pHead2;
        if(pHead2 == NULL) 
            return pHead1;
        ListNode * ans;
        if(pHead1->val < pHead2->val)
        {
            ans = pHead1;
            ans->next = Merge(pHead1->next,pHead2);
        }
        else
        {
            ans = pHead2;
            ans->next = Merge(pHead1, pHead2->next);
        }
        return ans;
    }
};
```

### 迭代

```c++
class Solution {
public:
    ListNode* Merge(ListNode* pHead1, ListNode* pHead2)
    {
        ListNode * ans = new ListNode(0);
        ListNode * temp = ans;
        while(pHead1 != NULL && pHead2 != NULL)
        {
            if(pHead1->val < pHead2->val)
            {
                ans->next = pHead1;
                ans = pHead1;
                pHead1 = pHead1->next;
            }
            else
            {
                ans->next = pHead2;
                ans = pHead2;
                pHead2 = pHead2->next;
            }
        }
        if(pHead1 == NULL) ans->next = pHead2;
        else  ans->next = pHead1;
        return temp->next;
    }
};
```

# 26. 树的子结构

[NowCoder](https://www.nowcoder.com/practice/6e196c44c7004d15b1610b9afca8bd88?tpId=13&tqId=11170&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 题目描述

<div align="center"> <img src="../pics//4583e24f-424b-4d50-8a14-2c38a1827d4a.png" width="500"/> </div><br>

## 解题思路

```c++
class Solution {
public:
    bool HasSubtree(TreeNode* pRoot1, TreeNode* pRoot2)
    {
        if(pRoot1 == NULL || pRoot2 == NULL) 
            return false;
        return Has(pRoot1, pRoot2) || 
               HasSubtree(pRoot1->left, pRoot2) || 
               HasSubtree(pRoot1->right, pRoot2);
    }
    bool Has(TreeNode* p1, TreeNode *p2)
    {
        if(p2 == NULL) return true;
        if(p1 == NULL) return false;
        if(p1->val == p2->val)
            return Has(p1->left,p2->left) && Has(p1->right, p2->right);
        else 
            return false; 
    }
};
```

# 27. 二叉树的镜像

[NowCoder](https://www.nowcoder.com/practice/564f4c26aa584921bc75623e48ca3011?tpId=13&tqId=11171&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 题目描述

<div align="center"> <img src="../pics//a2d13178-f1ef-4811-a240-1fe95b55b1eb.png" width="300"/> </div><br>

## 解题思路

```c++
class Solution {
public:
    void Mirror(TreeNode *pRoot) {
        if(pRoot == NULL) 
            return;
        Swap(pRoot);
        Mirror(pRoot->left);
        Mirror(pRoot->right);
    }
    void Swap(TreeNode * pRoot)
    {
        TreeNode *temp;
        temp = pRoot->left;
        pRoot->left = pRoot->right;
        pRoot->right = temp;
    }
};
```

# 28 对称的二叉树

[NowCder](https://www.nowcoder.com/practice/ff05d44dfdb04e1d83bdbdab320efbcb?tpId=13&tqId=11211&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 题目描述

<div align="center"> <img src="../pics//f42443e0-208d-41ea-be44-c7fd97d2e3bf.png" width="300"/> </div><br>

## 解题思路

```c++
class Solution {
public:
    bool isSymmetrical(TreeNode* pRoot)
    {
        if(pRoot == NULL) 
            return true;
        return isSame(pRoot->left, pRoot->right);
    }
    bool isSame(TreeNode * p1, TreeNode * p2)
    {
        if(p1 == NULL && p2 == NULL)     
            return true;
        if(p1 == NULL || p2 == NULL) 
            return false;
        if(p1->val == p2->val)
            return isSame(p1->left, p2->right) && isSame(p1->right, p2->left);
        else 
            return false;
    }
};
```

# 29. 顺时针打印矩阵

[NowCoder](https://www.nowcoder.com/practice/9b4c81a02cd34f76be2659fa0d54342a?tpId=13&tqId=11172&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 题目描述

下图的矩阵顺时针打印结果为：1, 2, 3, 4, 8, 12, 16, 15, 14, 13, 9, 5, 6, 7, 11, 10

<div align="center"> <img src="../pics//6539b9a4-2b24-4d10-8c94-2eb5aba1e296.png" width="300"/> </div><br>

## 解题思路

```c++
class Solution {
public:
    vector<int> printMatrix(vector<vector<int> > matrix) {
        int h = matrix.size(), w = matrix[0].size();
        
        int top = 0, bot = h-1, left = 0, right = w-1;
        
        vector<int> ans;
        if(h == 0 || w == 0) return ans;
        
        while(top <= bot && left <= right)
        {
            // left to right
            for(int i = left; i <= right; i ++)
                ans.push_back(matrix[top][i]);
            
            // top to bottom
            for(int i = top+1; i <= bot; i ++)
                ans.push_back(matrix[i][right]);
            
            // right to left
            if(top != bot)
                for(int i = right-1; i >= left; i --)
                    ans.push_back(matrix[bot][i]);
            
            if(left != right)
                for(int i = bot-1; i > top; i --)
                    ans.push_back(matrix[i][left]);
            
            top ++, bot --, left ++, right --;
        }
        return ans;
    }
};
```

# 30. 包含 min 函数的栈

[NowCoder](https://www.nowcoder.com/practice/4c776177d2c04c2494f2555c9fcc1e49?tpId=13&tqId=11173&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 题目描述

定义栈的数据结构，请在该类型中实现一个能够得到栈最小元素的 min 函数。

## 解题思路

```c++
class Solution {
public:
    void push(int value) {
        st.push(value);
        if(smin.empty() || smin.top() > value)
            smin.push(value);
    }
    void pop() {
        if(smin.top() == st.top())
            smin.pop();
        st.pop();
    }
    int top() {
        return st.top();
    }
    int min() {
        return smin.top();
    }
private:
    stack<int> st;
    stack<int> smin;
};
```

# 31. 栈的压入、弹出序列

[NowCoder](https://www.nowcoder.com/practice/d77d11405cc7470d82554cb392585106?tpId=13&tqId=11174&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 题目描述

输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。

例如序列 1,2,3,4,5 是某栈的压入顺序，序列 4,5,3,2,1 是该压栈序列对应的一个弹出序列，但 4,3,5,1,2 就不可能是该压栈序列的弹出序列。

## 解题思路

使用一个栈来模拟压入弹出操作。

```c++
class Solution {
public:
    bool IsPopOrder(vector<int> pushV,vector<int> popV) {
        int len = pushV.size();
        stack<int> st;
        for(int x = 0, y = 0; x < len; x ++)
        {
            st.push(pushV[x]);
            while(!st.empty() && st.top() == popV[y])
            {
                st.pop();
                y ++;
            }
        }
        return st.empty();
    }
};
```

# 32.1 从上往下打印二叉树

[NowCoder](https://www.nowcoder.com/practice/7fe2212963db4790b57431d9ed259701?tpId=13&tqId=11175&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 题目描述

从上往下打印出二叉树的每个节点，同层节点从左至右打印。

例如，以下二叉树层次遍历的结果为：1,2,3,4,5,6,7

<div align="center"> <img src="../pics//348bc2db-582e-4aca-9f88-38c40e9a0e69.png" width="250"/> </div><br>

## 解题思路

使用vector来保存要遍历的节点地址。类似bfs的过程

```c++
class Solution {
public:
    vector<int> PrintFromTopToBottom(TreeNode* root) {
        vector<int> ans;
        vector<TreeNode *> temp;
        if(root == NULL) return ans;
        temp.push_back(root);
        int ti = 0;
        while(ti < temp.size())
        {
            TreeNode * t = temp[ti];
            if(t->left != NULL) temp.push_back(t->left);
            if(t->right != NULL) temp.push_back(t->right);
            ti ++;
        }
        for(auto X : temp)
            ans.push_back(X->val);
        return ans;
    }
};
```

# 32.2 把二叉树打印成多行

[NowCoder](https://www.nowcoder.com/practice/445c44d982d04483b04a54f298796288?tpId=13&tqId=11213&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 题目描述

这里使用两个vector来缓存，相邻两次的遍历

## 解题思路

```c++
class Solution {
public:
        vector<vector<int> > Print(TreeNode* pRoot) {
            vector<vector<int> > ans;
            if(pRoot == NULL) return ans;
            vector<TreeNode *> ve1, ve2;
            ve1.push_back(pRoot);
            while(!ve1.empty() || !ve2.empty())
            {
                vector<int> temp;
                if(ve1.empty())
                {
                    for(auto x : ve2)
                    {
                        if(x->left != NULL) ve1.push_back(x->left);
                        if(x->right != NULL) ve1.push_back(x->right);
                        temp.push_back(x->val);
                    }
                    ve2.clear();
                }
                else
                {
                    for(auto x : ve1)
                    {
                        if(x->left != NULL) ve2.push_back(x->left);
                        if(x->right != NULL) ve2.push_back(x->right);
                        temp.push_back(x->val);
                    }
                    ve1.clear();
                }
                ans.push_back(temp);
            }
            return ans;
        }
};
```

# 32.3 按之字形顺序打印二叉树

[NowCoder](https://www.nowcoder.com/practice/91b69814117f4e8097390d107d2efbe0?tpId=13&tqId=11212&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 题目描述

请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。

## 解题思路

```c++
class Solution {
public:
    vector<vector<int> > Print(TreeNode* pRoot) {
        vector<vector<int> > ans;
        vector<TreeNode *> ve1, ve2;
        if(pRoot == NULL) return ans;
        ve1.push_back(pRoot);
        while(!ve1.empty() || !ve2.empty())
        {
            vector<int> temp;
            if(ve1.empty())
            {
                for(auto x : ve2)
                {
                    if(x->left != NULL) ve1.push_back(x->left);
                    if(x->right != NULL) ve1.push_back(x->right);
                    temp.push_back(x->val);
                }
                reverse(temp.begin(), temp.end());
                ve2.clear();
            }
            else
            {
                for(auto x : ve1)
                {
                    if(x->left != NULL) ve2.push_back(x->left);
                    if(x->right != NULL) ve2.push_back(x->right);
                    temp.push_back(x->val);
                }
                ve1.clear();
            }
            ans.push_back(temp);
        }
        return ans;
    }
};
```

# 33. 二叉搜索树的后序遍历序列

[NowCoder](https://www.nowcoder.com/practice/a861533d45854474ac791d90e447bafd?tpId=13&tqId=11176&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 题目描述

输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。假设输入的数组的任意两个数字都互不相同。

例如，下图是后序遍历序列 3,1,2 所对应的二叉搜索树。

<div align="center"> <img src="../pics//836a4eaf-4798-4e48-b52a-a3dab9435ace.png" width="150"/> </div><br>

## 解题思路

- BST的后序序列的合法序列是，对于一个序列S，最后一个元素是x （也就是根），如果去掉最后一个元素的序列为T，那么T满足：T可以分成两段，前一段（左子树）小于x，后一段（右子树）大于x，且这两段（子树）都是合法的后序序列。完美的递归定义。

```c++
class Solution {
public:
    bool VerifySquenceOfBST(vector<int> sequence) {
        if(sequence.empty()) return false;
        int len = sequence.size();
        return Verify(sequence, 0, len-1);
    }
    bool Verify(vector<int> ve, int start, int end)
    {
        if(end - start <= 1) return true;
        int root = ve[end];
        int index = start;
        while(index < end && ve[index] <= root)
            index ++;
        for(int i = index; i < end; i ++)
            if(ve[i] < root) return false;
        return Verify(ve,start,index-1) && Verify(ve, index, end-1);
    }
};
```

# 34. 二叉树中和为某一值的路径

[NowCoder](https://www.nowcoder.com/practice/b736e784e3e34731af99065031301bca?tpId=13&tqId=11177&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 题目描述

输入一颗二叉树和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。

下图的二叉树有两条和为 22 的路径：10, 5, 7 和 10, 12

<div align="center"> <img src="../pics//f5477abd-c246-4851-89ab-6b1cde2549b1.png" width="200"/> </div><br>

## 解题思路

- 全排列的思路，用temp缓存已经到达的地方， 出现合适的尾节点 插入ans


```c++
class Solution {
public:
    vector<vector<int> > FindPath(TreeNode* root,int expectNumber) {
        vector<vector<int>> ans;
        vector<int> temp;
        Find(ans, root, expectNumber, temp);
        return ans;
    }
    void Find(vector<vector<int>> &ans, TreeNode * root, int expect, vector<int> temp)
    {
        if(root == NULL) return;
        if(root->left == NULL && root->right == NULL)
        {
            if(expect == root->val) 
            {
                temp.push_back(root->val);
                ans.push_back(temp);
            }
        }
        else
        {
            temp.push_back(root->val);
            expect -= root->val;
            Find(ans, root->left, expect, temp);
            Find(ans, root->right, expect, temp);
        }
        return;
    }
};
```

# 35. 复杂链表的复制

[NowCoder](https://www.nowcoder.com/practice/f836b2c43afc4b35ad6adc41ec941dba?tpId=13&tqId=11178&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 题目描述

输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的 head。

```java
public class RandomListNode {
    int label;
    RandomListNode next = null;
    RandomListNode random = null;

    RandomListNode(int label) {
        this.label = label;
    }
}
```

<div align="center"> <img src="../pics//a01d1516-8168-461a-a24b-620b9cfc40f4.png" width="300"/> </div><br>

## 解题思路 纯copy

第一步，在每个节点的后面插入复制的节点。

<div align="center"> <img src="../pics//2e6c72f5-3b8e-4e32-b87b-9491322628fe.png" width="600"/> </div><br>

第二步，对复制节点的 random 链接进行赋值。

<div align="center"> <img src="../pics//323ffd6c-8b54-4f3e-b361-555a6c8bf218.png" width="600"/> </div><br>

第三步，拆分。

<div align="center"> <img src="../pics//8f3b9519-d705-48fe-87ad-2e4052fc81d2.png" width="600"/> </div><br>

```c++
class Solution {
public:
    RandomListNode* Clone(RandomListNode* pHead)
    {
        if(pHead == NULL) return NULL;
        nodeClone(pHead);
        connectRandom(pHead);
        return reconnect(pHead);
    }
    //复制结点，插入到原结点后方
    void nodeClone(RandomListNode * head)
    {
        RandomListNode *pNode = head;
        while(pNode != NULL)
        {
            RandomListNode *pClone = new RandomListNode(pNode->label);
            pClone->next = pNode->next;
            pNode->next = pClone;
            pNode = pClone->next;
        }
    }
    // 还原新节点的random指针
    void connectRandom(RandomListNode *head)
    {
        RandomListNode *pNode = head;
        while(pNode != NULL)
        {
            RandomListNode *pClone = pNode->next;
            if(pNode->random)
            {
                pClone->random = pNode->random->next;
            }
            pNode = pClone->next;
        }
    }
    // 拆分
    RandomListNode *reconnect(RandomListNode *head)
    {
        RandomListNode *pNode = head;
        RandomListNode *result = head->next;;
        while(pNode != NULL)
        {
            RandomListNode *pClone = pNode->next;
            pNode->next = pClone->next;
            pNode = pNode->next;
            if(pNode != NULL)
                pClone->next = pNode->next;
        }
        return result;
    }
};
```

# 36. 二叉搜索树与双向链表

[NowCoder](https://www.nowcoder.com/practice/947f6eb80d944a84850b0538bf0ec3a5?tpId=13&tqId=11179&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 题目描述

输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。

<div align="center"> <img src="../pics//79b12431-6d9d-4a7d-985b-1b79bc5bf5fb.png" width="400"/> </div><br>

## 解题思路   类似中序遍历 --

```c++
public:
    TreeNode * pre = NULL;
    TreeNode * head = NULL;
    TreeNode* Convert(TreeNode* pRootOfTree)
    {
        inOrder(pRootOfTree);
        return head;
    }
    void inOrder(TreeNode * root)
    {
        if(root == NULL) return;
        inOrder(root->left);
        root->left = pre;
        if(pre != NULL)
            pre->right = root;
        pre = root;
        if(head == NULL)
            head = root;
        inOrder(root->right);
    }
};
```

# 37. 序列化二叉树

[LeetCode](https://leetcode.com/problems/serialize-and-deserialize-binary-tree/description/)
## 题目描述
- 请实现两个函数，分别用来序列化和反序列化二叉树


## 解题思路
- 先序遍历序列化二叉树，反序列化按照 正向序列化的顺序

```c++
class Codec {
public:
    // Encodes a tree to a single string.
    string serialize(TreeNode* root) {
        if(root == NULL) return "#";
        string S = to_string(root->val) + "!";
        return S + serialize(root->left) + serialize(root->right);
    }
    // Decodes your encoded data to tree.
    TreeNode* deserialize(string data) {
        int i = 0;
        return deserialize(data, i);
    }
    TreeNode * deserialize(string &data, int &i)
    {
        if(data[i] == '#')
        {
            i ++;
            return NULL;
        }
        string s = "";
        while(data[i ++] != '!') // 判断为‘！’ 可以由下一个位置来开始
            s += data[i-1];
        TreeNode * T = new TreeNode(stoi(s));
        T->left = deserialize(data,i);
        T->right = deserialize(data,i);
        return T;
    }
};
```

# 38. 字符串的排列

[NowCoder](https://www.nowcoder.com/practice/fe6b651b66ae47d7acce78ffdd9a96c7?tpId=13&tqId=11180&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 题目描述

输入一个字符串，按字典序打印出该字符串中字符的所有排列。例如输入字符串 abc，则打印出由字符 a, b, c 所能排列出来的所有字符串 abc, acb, bac, bca, cab 和 cba。

## 解题思路

```c++
class Solution {
public:
    vector<string> Permutation(string str) {
        vector<string> ans;
        if(str.empty()) return ans;
        sort(str.begin(), str.end());
        Per(ans, 0, str);
        return ans;
    }
    void Per(vector<string> &ans, int k, string str)
    {
        if(k == str.length())
            ans.push_back(str);
        for(int i = k; i < str.length(); i ++)
        {
            if(i != k && str[k] == str[i])
                continue;
            swap(str[i], str[k]);
            Per(ans, k + 1, str);
        }
    }
};
```

# 39. 数组中出现次数超过一半的数字

[NowCoder](https://www.nowcoder.com/practice/e8a1b01a2df14cb2b228b30ee6a92163?tpId=13&tqId=11181&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 解题思路

多数投票问题，可以利用 Boyer-Moore Majority Vote Algorithm 来解决这个问题，使得时间复杂度为 O(N)。

使用 cnt 来统计一个元素出现的次数，当遍历到的元素和统计元素相等时，令 cnt++，否则令 cnt--。如果前面查找了 i 个元素，且 cnt == 0，说明前 i 个元素没有 majority，或者有 majority，但是出现的次数少于 i / 2 ，因为如果多于 i / 2 的话 cnt 就一定不会为 0 。此时剩下的 n - i 个元素中，majority 的数目依然多于 (n - i) / 2，因此继续查找就能找出 majority。
- 在遍历数组时保存两个值：一是数组中一个数字，一是次数。遍历下一个数字时，
- 若它与之前保存的数字相同，则次数加1，否则次数减1；若次数为0，则保存下一个数字，
- 并将次数置为1。遍历结束后，所保存的数字即为所求。然后再判断它是否符合条件即可。
```c++
class Solution {
public:
    int MoreThanHalfNum_Solution(vector<int> num) {
        int time = 0, temp;
        for(int i = 0; i < num.size(); i ++)
        {
            if(time == 0)
                time = 1, temp = num[i];
            else if(num[i] != temp)
                time --;
            else time ++;
        }
        time = 0;
        for(int i = 0; i < num.size(); i ++)
            if(num[i] == temp) time ++;
        return time*2 > num.size() ? temp : 0; 
    }
};
```

# 40. 最小的 K 个数

[NowCoder](https://www.nowcoder.com/practice/6a296eb82cf844ca8539b57c23e6e9bf?tpId=13&tqId=11182&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 解题思路

### 快速选择

- 复杂度：O(N) + O(1)
- 只有当允许修改数组元素时才可以使用

快速排序的 partition() 方法，会返回一个整数 j 使得 a[l..j-1] 小于等于 a[j]，且 a[j+1..h] 大于等于 a[j]，此时 a[j] 就是数组的第 j 大元素。可以利用这个特性找出数组的第 K 个元素，这种找第 K 个元素的算法称为快速选择算法。

```c++
class Solution {
public:
    int partition(vector<int> &input, int begin, int end) //标准的快排写法
    {
        int low = begin, high = end;
        int pivot = input[low];
        while(low < high)
        {
            while(low < high && input[high] >= pivot)
                high--;
            input[low] = input[high];
            while(low < high && input[low] <= pivot)
                low ++;
            input[high] = input[low];
        }
        input[low] = pivot;
        return low;
    }
    vector<int> GetLeastNumbers_Solution(vector<int> input, int k) {
        vector<int> ans;
        if(input.empty() || input.size() < k || k < 1)
            return ans;
        int start = 0, end = input.size()-1;
        int index = partition(input,start,end);
        while(index != (k-1))
        {
            if(index > k-1)
            {
                end = index-1;
                index = partition(input, start, end);
            }
            else
            {
                start = index+1;
                index = partition(input, start, end);
            }
        }
        ans.assign(input.begin(), input.begin()+k);
        return ans;
    }
};
```

### 大小为 K 的最小堆

- 复杂度：O(NlogK) + O(K)
- 特别适合处理海量数据

应该使用大顶堆来维护最小堆，而不能直接创建一个小顶堆并设置一个大小，企图让小顶堆中的元素都是最小元素。

维护一个大小为 K 的最小堆过程如下：在添加一个元素之后，如果大顶堆的大小大于 K，那么需要将大顶堆的堆顶元素去除。



# 41.1 数据流中的中位数

[NowCoder](https://www.nowcoder.com/practice/9be0172896bd43948f8a32fb954e1be1?tpId=13&tqId=11216&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 题目描述

如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。

## 解题思路

```c++
class Solution {
public:
    // 大顶堆处理左半边元素   // 小顶堆处理右半边元素
    priority_queue<int, vector<int>, less<int>> right;
    priority_queue<int, vector<int>, greater<int>> left;
    int N = 0;
    void Insert(int num)
    {
        // 已经有偶数个元素，此时插入右边  因为假定右边元素都大于左边元素
        // 需要先插入左边 得top后 再插入右边
        if(N % 2 == 0)
        {
            left.push(num);
            right.push(left.top());
            left.pop();
        }
        else
        {
            right.push(num);
            left.push(right.top());
            right.pop();
        }
        N ++;
    }
    double GetMedian()
    { 
        if(N % 2 == 1) return right.top();
        return (left.top() + right.top()) / 2.0;
    }
};
```

# 41.2 字符流中第一个不重复的字符

[NowCoder](https://www.nowcoder.com/practice/00de97733b8e4f97a3fb5c680ee10720?tpId=13&tqId=11207&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 题目描述

请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符 "go" 时，第一个只出现一次的字符是 "g"。当从该字符流中读出前六个字符“google" 时，第一个只出现一次的字符是 "l"。

## 解题思路
- 利用hash表来实现给你key 返回一个value 
- c++中可使用map和unordered_map实现
- 利用deque 的先进先出特性实现快速扫描

```c++
class Solution
{
public:
  //Insert one char from stringstream
    int Hash[128];
    deque<char> data;
    void Insert(char ch)
    {
         Hash[ch - '\0'] ++;
         if(Hash[ch - '\0'] == 1)
             data.push_back(ch);
    }
  //return the first appearence once char in current stringstream
    char FirstAppearingOnce()
    {
        while(!data.empty() && Hash[data.front()] != 1)
            data.pop_front();
        if(data.empty()) return '#';
        return data.front();
    }
};
```

# 42. 连续子数组的最大和

[NowCoder](https://www.nowcoder.com/practice/459bd355da1549fa8a49e350bf3df484?tpId=13&tqId=11183&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 题目描述

{6, -3, -2, 7, -15, 1, 2, 2}，连续子数组的最大和为 8（从第 0 个开始，到第 3 个为止）。

## 解题思路

```c++
class Solution {
public:
    int FindGreatestSumOfSubArray(vector<int> array) {
        if(array.empty()) return 0;
        int res = array[0];
        
        for(int i = 1; i < array.size(); i ++)
        {
            if(array[i-1] > 0) array[i] += array[i-1];
            res = max(res, array[i]);
        }
        return res;
    }
};
```

# 43. 从 1 到 n 整数中 1 出现的次数

[NowCoder](https://www.nowcoder.com/practice/bd7f978302044eee894445e244c7eee6?tpId=13&tqId=11184&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 解题思路
- 主要思路：设定整数点（如1、10、100等等）作为位置点i（对应n的各位、十位、百位等等），分别对每个数位上有    多少包含1的点进行分析
- 根据设定的整数位置，对n进行分割，分为两部分，高位n/i，低位n%i
- 当i表示百位，且百位对应的数>=2,如n=31456,i=100，则a=314,b=56，此时百位为1的次数有a/10+1=32（最高两位0~31），每一次都包含100个连续的点，即共有(a%10+1)*100个点的百位为1
- 当i表示百位，且百位对应的数为1，如n=31156,i=100，则a=311,b=56，此时百位对应的就是1，则共有a%10(最高两位0-30)次是包含100个连续点，当最高两位为31（即a=311），本次只对应局部点00~56，共b+1次，所有点加起来共有（a%10*100）+(b+1)，这些点百位对应为1
- 当i表示百位，且百位对应的数为0,如n=31056,i=100，则a=310,b=56，此时百位为1的次数有a/10=31（最高两位0~30）
- 综合以上三种情况，当百位对应0或>=2时，有(a+8)/10次包含所有100个点，还有当百位为1(a%10==1)，需要增加局部点b+1
- 之所以补8，是因为当百位为0，则a/10==(a+8)/10，当百位>=2，补8会产生进位位，效果等同于(a/10+1)

```c++
class Solution {
public:
    int NumberOf1Between1AndN_Solution(int n)
    {
        int ans = 0;
        for(int m = 1; m <= n; m *= 10)
        {
            int a = n / m, b = n % m;
            ans += (a + 8) / 10 * m + (a % 10 == 1 ? b + 1 : 0);
        }
        return ans;
    }
};
```

> [Leetcode : 233. Number of Digit One](https://leetcode.com/problems/number-of-digit-one/discuss/64381/4+-lines-O(log-n)-C++JavaPython)

# 44. 数字序列中的某一位数字

## 题目描述

数字以 0123456789101112131415... 的格式序列化到一个字符串中，求这个字符串的第 index 位。

## 解题思路

```java
public int getDigitAtIndex(int index) {
    if (index < 0)
        return -1;
    int place = 1;  // 1 表示个位，2 表示 十位...
    while (true) {
        int amount = getAmountOfPlace(place);
        int totalAmount = amount * place;
        if (index < totalAmount)
            return getDigitAtIndex(index, place);
        index -= totalAmount;
        place++;
    }
}

/**
 * place 位数的数字组成的字符串长度
 * 10, 90, 900, ...
 */
private int getAmountOfPlace(int place) {
    if (place == 1)
        return 10;
    return (int) Math.pow(10, place - 1) * 9;
}

/**
 * place 位数的起始数字
 * 0, 10, 100, ...
 */
private int getBeginNumberOfPlace(int place) {
    if (place == 1)
        return 0;
    return (int) Math.pow(10, place - 1);
}

/**
 * 在 place 位数组成的字符串中，第 index 个数
 */
private int getDigitAtIndex(int index, int place) {
    int beginNumber = getBeginNumberOfPlace(place);
    int shiftNumber = index / place;
    String number = (beginNumber + shiftNumber) + "";
    int count = index % place;
    return number.charAt(count) - '0';
}
```

# 45. 把数组排成最小的数

[NowCoder](https://www.nowcoder.com/practice/8fecd3f8ba334add803bf2a06af1b993?tpId=13&tqId=11185&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 题目描述

输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组 {3，32，321}，则打印出这三个数字能排成的最小数字为 321323。

## 解题思路

可以看成是一个排序问题，在比较两个字符串 S1 和 S2 的大小时，应该比较的是 S1+S2 和 S2+S1 的大小，如果 S1+S2 < S2+S1，那么应该把 S1 排在前面，否则应该把 S2 排在前面。

```c++
class Solution {
public:
    //为啥不加static就不通过，编译不了
    static bool cmp(int a, int b)
    {
        return to_string(a) + to_string(b) < to_string(b) + to_string(a);
    }
    string PrintMinNumber(vector<int> numbers) {
        string res;
        sort(numbers.begin(),numbers.end(),cmp);
        int len = numbers.size();
        for(int i = 0; i < len; i ++)
            res += to_string(numbers[i]);
        return res;
    }
};
```

# 46. 把数字翻译成字符串

[Leetcode](https://leetcode.com/problems/decode-ways/description/)

## 题目描述

给定一个数字，按照如下规则翻译成字符串：0 翻译成“a”，1 翻译成“b”... 25 翻译成“z”。一个数字有多种翻译可能，例如 12258 一共有 5 种，分别是 bccfi，bwfi，bczi，mcfi，mzi。实现一个函数，用来计算一个数字有多少种不同的翻译方法。

## 解题思路

```c++
class Solution {
public:
    int numDecodings(string s) {
        if(s.empty()) return 0;
        int len = s.length();
        vector<int> dp(len+1, 0);
        dp[0] = 1;
        dp[1] = (s[0] == '0' ? 0 : 1);
        for(int i = 2; i <= len; i ++)
        {
            int temp = 10 * (s[i-2] - '0') + s[i-1] - '0';
            if(temp <= 26 && temp >= 10)
                dp[i] += dp[i-2];
            
            if(s[i-1] != '0')
                dp[i] += dp[i-1];
        }
        return dp[len];
    }
};
```

# 47. 礼物的最大价值

[NowCoder](https://www.nowcoder.com/questionTerminal/72a99e28381a407991f2c96d8cb238ab)

## 题目描述

在一个 m\*n 的棋盘的每一个格都放有一个礼物，每个礼物都有一定价值（大于 0）。从左上角开始拿礼物，每次向右或向下移动一格，直到右下角结束。给定一个棋盘，求拿到礼物的最大价值。例如，对于如下棋盘

```
1    10   3    8
12   2    9    6
5    7    4    11
3    7    16   5
```

礼物的最大价值为 1+12+5+7+7+16+5=53。

## 解题思路

应该用动态规划求解，而不是深度优先搜索，深度优先搜索过于复杂，不是最优解。

```c++
class Bonus {
public:
    int getMost(vector<vector<int> > board) {
        int n = board.size(), m = board.front().size();
        vector<vector<int>> dp(n+1, vector<int>(m+1,0));
        for(int i = 1; i <= n; i ++)
            for(int j = 1; j <= m; j ++)
            {
                dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + board[i-1][j-1];
            }
        return dp[n][m];
    }
};
```

# 48. 最长不含重复字符的子字符串

[LeetCode](https://leetcode.com/problems/longest-substring-without-repeating-characters/description/)

## 题目描述

输入一个字符串（只包含 a\~z 的字符），求其最长不含重复字符的子字符串的长度。例如对于 arabcacfr，最长不含重复字符的子字符串为 acfr，长度为 4。

## 解题思路

中数组来缓存每次出现char的最后一个位置 每次更新  且计算最大值

```c++
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        vector<int> index(256, -1);
        int ans = 0, start = -1;
        for(int i = 0; i < s.length(); i ++)
        {
            int temp = s[i];
            if(index[temp] > start)   
                start = index[temp];    // 出现重复，从重复位置开始的下面才开始判断
            index[temp] = i;
            ans = max(ans, i-start);
        }
        return ans;
    }
};
```

# 49. 丑数

[NowCoder](https://www.nowcoder.com/practice/6aa9e04fc3794f68acf8778237ba065b?tpId=13&tqId=11186&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 题目描述

把只包含因子 2、3 和 5 的数称作丑数（Ugly Number）。例如 6、8 都是丑数，但 14 不是，因为它包含因子 7。习惯上我们把 1 当做是第一个丑数。求按从小到大的顺序的第 N 个丑数。

## 解题思路

- 每一个丑数都是由其他丑数*2/3/5而得到的  从1开始 1*2 1*3 1*5其中一定有某个数是下一个丑数

- 这里2是想一个丑数 1*2已经出现 2*2 在和1*3 1*5比较 1*3最小 

- 2 * 2，2 * 3，1 * 5比较，每一个丑数*2 *3 *5都可能是下一个丑数 从到后每一个位置都尝试三种乘法

```c++
class Solution {
public:
    int GetUglyNumber_Solution(int index) {
        if(index == 0) return 0;
        if(index == 1) return 1;
        int t2 = 0, t3 = 0, t5 = 0;
        vector<int> dp(index, 0);
        dp[0] = 1;
        for(int i = 1; i < index; i ++)
        {
            dp[i] = min(dp[t2] * 2, min(dp[t3] * 3, dp[t5] * 5));
            if(dp[i] == dp[t2] * 2) t2 ++;
            if(dp[i] == dp[t3] * 3) t3 ++;
            if(dp[i] == dp[t5] * 5) t5 ++;
        }
        return dp[index-1];
    }
};
```

# 50. 第一个只出现一次的字符位置

[NowCoder](https://www.nowcoder.com/practice/1c82e8cf713b4bbeb2a5b31cf5b0417c?tpId=13&tqId=11187&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 题目描述

在一个字符串 中找到第一个只出现一次的字符，并返回它的位置。

## 解题思路

最直观的解法是使用 HashMap 对出现次数进行统计，但是考虑到要统计的字符范围有限，因此可以使用整型数组代替 

```c++
class Solution {
public:
    int FirstNotRepeatingChar(string str) {
        vector<int> dp(256,0);
        for(auto x : str)
            dp[x] ++;
        for(int i = 0; i < str.length(); i ++)
            if(dp[str[i]] == 1)
                return i;
        return -1;
    }
};
```

以上实现的空间复杂度还不是最优的。考虑到只需要找到只出现一次的字符，那么需要统计的次数信息只有 0,1,更大，使用两个比特位就能存储这些信息。

```java
public int FirstNotRepeatingChar2(String str) {
    BitSet bs1 = new BitSet(256);
    BitSet bs2 = new BitSet(256);
    for (char c : str.toCharArray()) {
        if (!bs1.get(c) && !bs2.get(c))
            bs1.set(c);     // 0 0 -> 0 1
        else if (bs1.get(c) && !bs2.get(c))
            bs2.set(c);     // 0 1 -> 1 1
    }
    for (int i = 0; i < str.length(); i++) {
        char c = str.charAt(i);
        if (bs1.get(c) && !bs2.get(c))  // 0 1
            return i;
    }
    return -1;
}
```

# 51. 数组中的逆序对

[NowCoder](https://www.nowcoder.com/practice/96bd6684e04a44eb80e6a68efc0ec6c5?tpId=13&tqId=11188&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 题目描述

在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。

## 解题思路

具体思路是在归并排序的合并阶段 后一段元素小于前面元素时加上 += (len1-x)大小

```c++
class Solution {
public:
    int InversePairs(vector<int> &data) {
        int len = data.size();
        if(len <= 1) return 0;
        vector<int> ve1, ve2;
        ve1.assign(data.begin(), data.begin()+len/2);
        ve2.assign(data.begin()+len/2, data.end());
        long long ans = 0;
        ans += InversePairs(ve1) + InversePairs(ve2);
        int len1 = ve1.size(), len2 = ve2.size();
        int x = 0, y = 0;
        vector<int> temp;
        while(x < len1 || y < len2)
        {
            if(x >= len1 || (y < len2 && ve1[x] > ve2[y]))
            {
                temp.push_back(ve2[y ++]);
                ans += (len1 - x);
            }
            else temp.push_back(ve1[x ++]);
        }
        for(int i = 0; i < len; i ++)
            data[i] = temp[i];
        return (ans) % 1000000007;
    }
};
```

# 52. 两个链表的第一个公共结点

[NowCoder](https://www.nowcoder.com/practice/6ab1d9a29e88450685099d45c9e31e46?tpId=13&tqId=11189&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 题目描述

<div align="center"> <img src="../pics//8f6f9dc9-9ecd-47c8-b50e-2814f0219056.png" width="500"/> </div><br>

## 解题思路

设 A 的长度为 a + c，B 的长度为 b + c，其中 c 为尾部公共部分长度，可知 a + c + b = b + c + a。

当访问链表 A 的指针访问到链表尾部时，令它从链表 B 的头部重新开始访问链表 B；同样地，当访问链表 B 的指针访问到链表尾部时，令它从链表 A 的头部重新开始访问链表 A。这样就能控制访问 A 和 B 两个链表的指针能同时访问到交点。

```c++
class Solution {
public:
    ListNode* FindFirstCommonNode( ListNode* pHead1, ListNode* pHead2) {
        ListNode * l1 = pHead1;
        ListNode * l2 = pHead2; // ListNode * l1 = pHead1, * l2 = pHead2;
        while(l1 != l2)
        {
            l1 = (l1 == NULL ? pHead2 : l1->next);
            l2 = (l2 == NULL ? pHead1 : l2->next);
        }
        return l2;
    }
};
```

# 53. 数字在排序数组中出现的次数

[NowCoder](https://www.nowcoder.com/practice/70610bf967994b22bb1c26f9ae901fa2?tpId=13&tqId=11190&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 题目描述

```html
Input:
nums = 1, 2, 3, 3, 3, 3, 4, 6
K = 3

Output:
4
```

## 解题思路

```c++
class Solution {
public:
    int GetNumberOfK(vector<int> data ,int k) {
        int first = bSearch(data,k);
        int last = bSearch(data,k+1);
        if(first == data.size() || data[first] != k)
            return 0;
        return last-first;
    }
    int bSearch(vector<int> data, int num)
    {
        int l = 0, r = data.size();
        while(l < r)
        {
            int m = (l + r) >> 1;
            if(data[m] < num)
                l = m + 1;
            else r = m;
        }
        return l;
    }
};
```

# 54. 二叉查找树的第 K 个结点

[NowCoder](https://www.nowcoder.com/practice/ef068f602dde4d28aab2b210e859150a?tpId=13&tqId=11215&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 解题思路

利用二叉查找树中序遍历有序的特点。

```c++
class Solution {
public:
    int cnt = 0;
    TreeNode *ans = NULL;
    TreeNode* KthNode(TreeNode* pRoot, int k)
    {
        findKth(pRoot,k);
        return ans;
    }
    void findKth(TreeNode * pRoot, int k)
    {
        if(pRoot == NULL) return;
        findKth(pRoot->left, k);
        cnt ++;
        if(cnt == k)
            ans = pRoot;
        findKth(pRoot->right, k);
    }
};
```

# 55.1 二叉树的深度

[NowCoder](https://www.nowcoder.com/practice/435fb86331474282a3499955f0a41e8b?tpId=13&tqId=11191&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 题目描述

从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。

<div align="center"> <img src="../pics//b29f8971-9cb8-480d-b986-0e60c2ece069.png" width="350"/> </div><br>

## 解题思路

```c++
class Solution {
public:
    int TreeDepth(TreeNode* pRoot)
    {
    	if(pRoot == NULL) return 0;
        return 1 + max(TreeDepth(pRoot->left), TreeDepth(pRoot->right));
    }
};
```

# 55.2 平衡二叉树

[NowCoder](https://www.nowcoder.com/practice/8b3b95850edb4115918ecebdf1b4d222?tpId=13&tqId=11192&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 题目描述

平衡二叉树左右子树高度差不超过 1。

<div align="center"> <img src="../pics//e026c24d-00fa-4e7c-97a8-95a98cdc383a.png" width="300"/> </div><br>

## 解题思路

```c++
class Solution {
public:
    bool Balance = true;
    bool IsBalanced_Solution(TreeNode* pRoot) {
        height(pRoot);
        return Balance;
    }
    int height(TreeNode * root)
    {
        if(root == NULL || !Balance)
            return 0;
        int left = height(root->left);
        int right = height(root->right);
        if(abs(left-right) > 1)
            Balance = false;
        return 1 + max(left, right);
    }
};
```

# 56. 数组中只出现一次的数字

[NowCoder](https://www.nowcoder.com/practice/e02fdb54d7524710a7d664d082bb7811?tpId=13&tqId=11193&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 题目描述

一个整型数组里除了两个数字之外，其他的数字都出现了两次，找出这两个数。

## 解题思路

两个不相等的元素在位级表示上必定会有一位存在不同，将数组的所有元素异或得到的结果为不存在重复的两个元素异或的结果。

diff &= -diff 得到出 diff 最右侧不为 0 的位，也就是不存在重复的两个元素在位级表示上最右侧不同的那一位，利用这一位就可以将两个元素区分开来。

```c++
class Solution {
public:
    void FindNumsAppearOnce(vector<int> data,int* num1,int *num2) {
        int diff = 0;
        for(auto x : data)
            diff ^= x;
        diff &= -diff; //得出最后一位
        for(auto x : data)
        {
            if(x & diff)
                num1[0] ^= x;
            else
                num2[0] ^= x;
        }
        return;
    }
};
```

# 57.1 和为 S 的两个数字

[NowCoder](https://www.nowcoder.com/practice/390da4f7a00f44bea7c2f3d19491311b?tpId=13&tqId=11195&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 题目描述

输入一个递增排序的数组和一个数字 S，在数组中查找两个数，使得他们的和正好是 S。如果有多对数字的和等于 S，输出两个数的乘积最小的。

## 解题思路

使用双指针，一个指针指向元素较小的值，一个指针指向元素较大的值。指向较小元素的指针从头向尾遍历，指向较大元素的指针从尾向头遍历。

- 如果两个指针指向元素的和 sum == target，那么得到要求的结果；
- 如果 sum > target，移动较大的元素，使 sum 变小一些；
- 如果 sum < target，移动较小的元素，使 sum 变大一些。

```c++
class Solution {
public:
    vector<int> FindNumbersWithSum(vector<int> array,int sum) {
        int len = array.size();
        int i = 0, j = len-1;
        while(i < j)
        {
            if(array[i] + array[j] == sum)
                return {array[i], array[j]};
            if(array[i] + array[j] < sum)
                i ++;
            if(array[i] + array[j] > sum)
                j --;
        }
        return {};
    }
};
```

# 57.2 和为 S 的连续正数序列

[NowCoder](https://www.nowcoder.com/practice/c451a3fd84b64cb19485dad758a55ebe?tpId=13&tqId=11194&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 题目描述

输出所有和为 S 的连续正数序列。

例如和为 100 的连续序列有：

```
[9, 10, 11, 12, 13, 14, 15, 16]
[18, 19, 20, 21, 22]。
```

## 解题思路

刚才问题的加强版，这里讨论的是一个子串之和为给定值的全部解从{1,2}一点点扩大  
和 < sum 右边界增大  cursum+end;
和 > sum 左边界增大  cursum-start;
和 = sum 放入ans;
```c++
class Solution {
public:
    vector<vector<int> > FindContinuousSequence(int sum) {
        vector<vector<int>> ans;
        int start = 1, end = 2;
        int cursum = 1+2;
        while(end < sum)
        {
            if(cursum < sum)
            {
                end ++;
                cursum += end;
            }
            else if(cursum > sum)
            {
                cursum -= start;
                start ++;
            }
            else 
            {
                ans.push_back(getV(start,end));
                end ++;
                cursum += end;
            }
        }
        return ans;
    }
    vector<int> getV(int start, int end)
    {
        vector<int> temp;
        for(int i = start; i <= end; i ++)
            temp.push_back(i);
        return temp;
    }
};
```

# 58.1 翻转单词顺序列

[NowCoder](https://www.nowcoder.com/practice/3194a4f4cf814f63919d0790578d51f3?tpId=13&tqId=11197&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 题目描述

```html
Input:
"I am a student."

Output:
"student. a am I"
```

## 解题思路

题目应该有一个隐含条件，就是不能用额外的空间。虽然 Java 的题目输入参数为 String 类型，需要先创建一个字符数组使得空间复杂度为 O(N)，但是正确的参数类型应该和原书一样，为字符数组，并且只能使用该字符数组的空间。任何使用了额外空间的解法在面试时都会大打折扣，包括递归解法。

正确的解法应该是和书上一样，先旋转每个单词，再旋转整个字符串。

```c++
class Solution {
public:
    string ReverseSentence(string str) {
        int len = str.length();
        int i = 0, j = 0;
        for(j = 0; j <= len; j ++)
        {
            if(str[j] == ' ' || j == len)
            {
                Reverse(str,i,j-1);
                i = j + 1;
            }
        }
        Reverse(str, 0, len-1);
        return str;
    }
    void Reverse(string &str, int start, int end)
    {
        while(start < end)
        {
            swap(str[start], str[end]);
            start ++, end --;
        }
    }
};
```

# 58.2 左旋转字符串

[NowCoder](https://www.nowcoder.com/practice/12d959b108cb42b1ab72cef4d36af5ec?tpId=13&tqId=11196&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 题目描述

```html
Input:
S="abcXYZdef"
K=3

Output:
"XYZdefabc"
```

## 解题思路

先将 "abc" 和 "XYZdef" 分别翻转，得到 "cbafedZYX"，然后再把整个字符串翻转得到 "XYZdefabc"。

```c++
class Solution {
public:
    string LeftRotateString(string str, int n) {
        if(str.empty() || n >= str.length()) return str; // n和长度做一个判断
        Reverse(str, 0, n-1);
        Reverse(str, n, str.length() - 1);
        Reverse(str, 0, str.length() - 1);
        return str;
    }
    void Reverse(string &str, int start, int end)
    {
        while(start < end)
        {
            swap(str[start], str[end]);
            start ++, end --;
        }
    }
};
```

# 59. 滑动窗口的最大值

[NowCoder](https://www.nowcoder.com/practice/1624bc35a45c42c0bc17d17fa0cba788?tpId=13&tqId=11217&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 题目描述

给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。

例如，如果输入数组 {2, 3, 4, 2, 6, 2, 5, 1} 及滑动窗口的大小 3，那么一共存在 6 个滑动窗口，他们的最大值分别为 {4, 4, 6, 6, 6, 5}。

## 解题思路

```c++
class Solution {
public:
    vector<int> maxInWindows(const vector<int>& num, unsigned int size)
    {
        vector<int> res;
        deque<int> s;
        for(int i = 0; i < num.size(); i ++)
        {
            while(!s.empty() && num[s.back()] <= num[i]) s.pop_back();
            while(!s.empty() && i-s.front() >= size) s.pop_front();
            s.push_back(i);
            if(size && i+1 >= size)
            {
                res.push_back(num[s.front()]);
            }
        }
        return res;
    }
};
```

# 60. n 个骰子的点数

[Lintcode](https://www.lintcode.com/en/problem/dices-sum/)

## 题目描述

把 n 个骰子仍在地上，求点数和为 s 的概率。

## 解题思路

### 动态规划解法

使用一个二维数组 dp 存储点数出现的次数，其中 dp[i][j] 表示前 i 个骰子产生点数 j 的概率。
后一个骰子可能有6种不同的表现。

空间复杂度：O(N<sup>2</sup>)

```c++
class Solution {
public:
    vector<pair<int, double>> dicesSum(int n) {
        double dp[n+1][n*6+1] = {0};
        for(int i = 1; i <= 6; i ++)
            dp[1][i] = 1.0 / 6;
            
        for(int i = 2; i <= n; i ++)
            for(int j = i; j <= 6*i; j ++)
            {
                for(int k = 1; k <= 6; k ++)
                {
                    if(j - k >= 1) dp[i][j] += dp[i-1][j-k] * 1.0/6;
                }
            }
        vector<pair<int, double>> ans;
        
        for(int i = n; i <= 6*n; i ++)
            ans.push_back({i, dp[n][i]});
            
        return ans;
    }
};
```



# 61. 扑克牌顺子

[NowCoder](https://www.nowcoder.com/practice/762836f4d43d43ca9deb273b3de8e1f4?tpId=13&tqId=11198&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 题目描述

五张牌，其中大小鬼为癞子，牌面大小为 0。判断这五张牌是否能组成顺子。

## 解题思路

```c++
class Solution {
public:
    bool IsContinuous( vector<int> num ) {
        if(num.empty()) return false;
        sort(num.begin(), num.end());
        int len = num.size();
        int zero = 0;
        for(int i = 0; i < len; i ++)
            if(num[i] == 0)
                zero ++;
        int dis = 0;
        for(int i = zero+1; i < len; i ++)
        {
            if(num[i] == num[i-1]) return false;  //注意前后两者 相等的情况 num长度不确定
            dis += num[i] - num[i-1] - 1;
        }
        if(dis <= zero) 
            return true;
        return false;
    }
};
```

# 62. 圆圈中最后剩下的数

[NowCoder](https://www.nowcoder.com/practice/f78a359491e64a50bce2d89cff857eb6?tpId=13&tqId=11199&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 题目描述

让小朋友们围成一个大圈。然后，随机指定一个数 m，让编号为 0 的小朋友开始报数。每次喊到 m-1 的那个小朋友要出列唱首歌，然后可以在礼品箱中任意的挑选礼物，并且不再回到圈中，从他的下一个小朋友开始，继续 0...m-1 报数 .... 这样下去 .... 直到剩下最后一个小朋友，可以不用表演。

## 解题思路

约瑟夫环，圆圈长度为 n 的解可以看成长度为 n-1 的解再加上报数的长度 m。因为是圆圈，所以最后需要对 n 取余。

0, 1, 2, 3, 4, 5, ..., m-1, m, ..., n-2, n-1
0, 1, 2, 3, 4, 5, ... |m-1| m, ..., n-2, n-1 // 第一次取出m-1下标的元素
k+2, k+3, ..., n-2          0, ..., k,   k+1 // 再取元素相当于从0~n-2个元素中取出元素 
                                             // 这里取出的元素 下标 (x + m) % n可以得到原数组的下标
```c++
class Solution {
public:
    int LastRemaining_Solution(int n, int m)
    {
        if(n == 0) return -1;
        if(n == 1) return 0;
        return (LastRemaining_Solution(n-1,m) + m) % n;
    }
};
```

# 63. 股票的最大利润

[Leetcode](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/description/)

## 题目描述

可以有一次买入和一次卖出，买入必须在前。求最大收益。

## 解题思路

使用贪心策略，假设第 i 轮进行卖出操作，买入操作价格应该在 i 之前并且价格最低。
暂存i之前的最小值 和 结果

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        if(prices.empty() || prices.size() == 1)
            return 0;
        int ans = 0, small = prices[0];
        int len = prices.size();
        for(int i = 1; i < len; i ++)
        {
            small = min(small, prices[i]);
            ans = max(ans, prices[i]-small);
        }
        return ans;
    }
};
```

# 64. 求 1+2+3+...+n

[NowCoder](https://www.nowcoder.com/practice/7a0da8fc483247ff8800059e12d7caf1?tpId=13&tqId=11200&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 题目描述

要求不能使用乘除法、for、while、if、else、switch、case 等关键字及条件判断语句 A ? B : C。

## 解题思路

使用递归解法最重要的是指定返回条件，但是本题无法直接使用 if 语句来指定返回条件。

条件与 && 具有短路原则，即在第一个条件语句为 false 的情况下不会去执行第二个条件语句。利用这一特性，将递归的返回条件取非然后作为 && 的第一个条件语句，递归的主体转换为第二个条件语句，那么当递归的返回条件为 true 的情况下就不会执行递归的主体部分，递归返回。

本题的递归返回条件为 n <= 0，取非后就是 n > 0；递归的主体部分为 sum += Sum_Solution(n - 1)，转换为条件语句后就是 (sum += Sum_Solution(n - 1)) > 0。

```c++
class Solution {
public:
    int Sum_Solution(int n) {
        int sum = n;
        int x = (n > 0) && (sum += Sum_Solution(n-1));
        return sum;
    }
};
```

# 65. 不用加减乘除做加法

[NowCoder](https://www.nowcoder.com/practice/59ac416b4b944300b617d4f7f111b215?tpId=13&tqId=11201&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 题目描述

写一个函数，求两个整数之和，要求不得使用 +、-、\*、/ 四则运算符号。

## 解题思路

a ^ b 表示没有考虑进位的情况下两数的和，(a & b) << 1 就是进位。

递归会终止的原因是 (a & b) << 1 最右边会多一个 0，那么继续递归，进位最右边的 0 会慢慢增多，最后进位会变为 0，递归终止。

```c++
class Solution {
public:
    int Add(int num1, int num2)
    {
        return num2 == 0 ? num1 : Add(num1 ^ num2, (num1 & num2) << 1);
    }
};
```

# 66. 构建乘积数组

[NowCoder](https://www.nowcoder.com/practice/94a4d381a68b47b7a8bed86f2975db46?tpId=13&tqId=11204&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 题目描述

给定一个数组 A[0, 1,..., n-1]，请构建一个数组 B[0, 1,..., n-1]，其中 B 中的元素 B[i]=A[0]\*A[1]\*...\*A[i-1]\*A[i+1]\*...\*A[n-1]。要求不能使用除法。

## 解题思路

```c++
class Solution {
public:
    vector<int> multiply(const vector<int>& A) {
        int len = A.size();
        vector<int> ans(len,1);
        
        for(int i = 1; i < len; i ++)
            ans[i] = ans[i-1] * A[i-1]; // 从左向右累乘 a[i] = A[0] * * * A[i-1]
        
        for(int i = len-1, pro = 1; i >= 0; pro *= A[i], i --)  // 从右向左累乘
            ans[i] *= pro;
        return ans;
    }
};
```

# 67. 把字符串转换成整数

[NowCoder](https://www.nowcoder.com/practice/1277c681251b4372bdef344468e4f26e?tpId=13&tqId=11202&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 题目描述

将一个字符串转换成一个整数，字符串不是一个合法的数值则返回 0，要求不能使用字符串转换整数的库函数。

```html
Iuput:
+2147483647
1a33

Output:
2147483647
0
```

## 解题思路

```c++
class Solution {
public:
    int StrToInt(string str) {
        if(str.empty()) return 0;
        int len = str.length();
        bool flag = true;
        int res = 0;
        for(int i = 0; i < len; i ++)
        {
            if(i == 0 && (str[i] == '-' || str[i] == '+'))
            {
                flag = str[i] == '-' ? false : true;
            }
            else if(str[i] > '9' || str[i] < '0')
                return 0;
            else
                res = res * 10 + str[i] - '0';
        }
        return flag ? res : -res;
    }
};
```

# 68. 树中两个节点的最低公共祖先

## 解题思路

### 二叉查找树

<div align="center"> <img src="../pics//293d2af9-de1d-403e-bed0-85d029383528.png" width="300"/> </div><br>

[Leetcode : 235. Lowest Common Ancestor of a Binary Search Tree](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/description/)

二叉查找树中，两个节点 p, q 的公共祖先 root 满足 root.val >= p.val && root.val <= q.val。

```c++
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if(root == NULL) return root;
        if(root->val > p->val && root->val > q->val)
            return lowestCommonAncestor(root->left, p, q);
        if(root->val < p->val && root->val < q->val)
            return lowestCommonAncestor(root->right,p, q);
        return root;
    }
};
```

### 普通二叉树

<div align="center"> <img src="../pics//37a72755-4890-4b42-9eab-b0084e0c54d9.png" width="300"/> </div><br>

[Leetcode : 236. Lowest Common Ancestor of a Binary Tree](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/description/)

在左右子树中查找是否存在 p 或者 q，如果 p 和 q 分别在两个子树中，那么就说明根节点就是最低公共祖先。

```c++
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if(root == NULL || root == p || root == q)
            return root;
        TreeNode * left = lowestCommonAncestor(root->left, p, q);   //左半边的答案
        TreeNode * right = lowestCommonAncestor(root->right, p, q); //右半边的答案
        return left == NULL ? right : right == NULL ? left : root;
         
    }
};
```

# 参考文献

- 何海涛. 剑指 Offer[M]. 电子工业出版社, 2012.
